## <H> ********************************************************************************************************************
## Coursera R Programming Class (rprog-002)
## Peer Assessments /Programming Assignment 2
## by Roger D. Peng, Brian Caffo, PhD, Jeff Leek
## ********************************************************************************************************************
## Script Name: cachematrix.R
## Create by: Unshar - April 23, 2014
## Objective: Create a R function that is able to cache time-consuming computations.
##
## SOURCE DATA: no external data files being used in this script
## OUTPUT DATA: no data files being generated by this script
## <H/> ********************************************************************************************************************

## Function 'a'
## makeCacheMatrix: The first function, makeVector creates a special "vector", which is really a list containing a function to:
## a1 - set the value of the matrix
## a2 - get the value of the matrix
## a3 - set the value of the inverse
## a4 - get the value of the inverse

makeCacheMatrix<- function(x = matrix()) {
  ## Creates a special "matrix" object that can cache its inverse.
  inv<- NULL
  set <- function(x = matrix()) { #a1
    x <<- y
    inv <<- NULL
  }
  get <- function() x #a2
  setInv <- function(inv) inv <<- solve #a3
  getInv <- function() inv #a4
  list(set = set, get = get,
       setInv = setInv,
       getInv = getInv)
}


## Function 'b' - cacheSolve: This function computes the inverse of the special "matrix" returned by makeCacheMatrix above. 
##  b1 -it first checks to see if the inverse has already been calculated. 
##  b2 - If so, it gets the inverse from the cache and skips the computation. 
##  b3 - Otherwise, it calculates the inverse of the data and;
##  b4 - sets the value of the inverse in the cache via the setInv function.

cacheSolve <- function(x, ...) {
  ## Return a matrix that is the inverse of 'x'
  inv <- x$getInv()
  if(!is.null(inv)) { #b1
    message("getting cached inverse matrix")
    return(inv) #b2
  }
  data <- x$inv()
  inv <- solve(data, ...) #b3
  x$setInv(inv) #b4
  inv
}
